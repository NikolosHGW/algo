## Решение:
```go
func twoSum(nums []int, target int) []int {
    result := make([]int, 2)

    p1 := 0
    p2 := len(nums) - 1

    for p1 < p2 {
        sum := nums[p1] + nums[p2]

        if sum == target {
            result[0] = p1 + 1
            result[1] = p2 + 1
            
            return result
        }

        if sum > target {
            p2--
        } else {
            p1++
        }
    }

    result[0] = -1
    result[1] = -1

    return result
} 
```

## Оценка по времени:
O(n) - где n - размер входного слайса nums

Объяснение: в самом худшем случае я прохожусь ровно по всем элементам слайса двумя указателями

## Оценка по памяти:
O(1)

Объяснение: я аллоцирую память только под пару переменных и результирующий слайс, который я инициализирую с фиксированной длиной 2. То есть, какой бы не был размер входного слайса, мой результирующий слайс и остальные вспомогательные переменные не меняются, остаются константами.

## Описание решения:
Инициализирую результатирующий слайс `result` с длиной 2, создаю два указателя на начальный индекс и конечный, затем реализую цикл с условием, чтобы он итерировался, пока два указателя не встретятся (не включительно), то есть, пока первый указатель меньше второго, это даёт проход по всем элементам слайса. Затем внутри цикла проверяю сумму значений по этим указателям, если он равен таргету, то записываю указатели с прибавлением 1 в результатирующий слайс `result`, если сумма больше, чем таргет, то уменьшаю второй указатель, так как раз сумма уже больше, а слайс у меня отсортирован в порядке возрастания, то смысла поднимать первый указатель дальше нет, так как сумма будет становиться ещё больше, поэтому мы уменьшаем второе слогаемое, то бишь занижаем второй указатель, а если наоборот сумма меньше таргета, то нам надо увеличить первое слогаемое, то бишь поднять первый указатель
