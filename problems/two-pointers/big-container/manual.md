## Решение:
```go
func maxArea(height []int) int {
    r := 0

    p1 := 0
    p2 := len(height) - 1

    for p1 < p2 {
        h1 := height[p1]
        h2 := height[p2]
        
        area := minHeight(h1, h2) * (p2 - p1)

        if area > r {
            r = area
        }

        if h1 < h2 {
            p1++
        } else {
            p2--
        }
    }

    return r
}

func minHeight(n1, n2 int) int {
    if n1 < n2 {
        return n1
    }

    return n2
}
```

## Оценка по времени:
O(n) - где n - размер входного слайса

Объяснение: мы всегда проходим по всем элементам слайса двумя указателями, то есть, два указателя, сдвигающихся друг к другу, пройдут в сумме все элементы слайса.

## Оценка по памяти:
O(1)

Объяснение: мы аллоцируем вспомогательный переменные одинаковое кол-во при любом размере входного слайса, то есть, независимо от размера слайса

## Описание решения:
Ищу максимальную площадь с помощью двух указателей. Условием для движения указателей является проверка на минимальное значение высоты указателя, то есть, по какому указателю значение меньше, тот указатель и двигаю. На каждой итерации просчитываю площадь, и, если она больше предыдущей площади, то записываю её в результат, в итоге алгоритм всегда будет проходить по всем элементам массива, а после окончания цикла вернёт результирующую площадь
