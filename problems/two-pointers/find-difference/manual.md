## Решение:
```go
func findDifference(nums1 []int, nums2 []int) []int {
    result := make([]int, 0, len(nums1) + len(nums2))

    p1 := 0
    p2 := 0

    for p1 < len(nums1) || p2 < len(nums2) {
        if p1 >= len(nums1) && p2 < len(nums2) {
            result = append(result, nums2[p2])
            p2++
            continue
        }
        if p2 >= len(nums2) && p1 < len(nums1) {
            result = append(result, nums1[p1])
            p1++
            continue
        }

        if nums1[p1] < nums2[p2] {
            result = append(result, nums1[p1])
            p1++
        } else if nums2[p2] < nums1[p1] {
            result = append(result, nums2[p2])
            p2++
        } else {
            p1++
            p2++
        }
    }

    return result
}
```

## Оценка по времени:
O(n + m) - где n - размер входного массива nums1, m - размер входного массива nums2.

Объяснение: с помощью паттерна "каждому по указателю" мы ставим на каждый массив в начало указатель и двигаем до конца массива одним циклом, в итоге получается, что мы должны на двух массивах пройти все элементы в сумме, а массивы могут быть разной длины.

## Оценка по памяти:
O(n + m) - где n - размер входного массива nums1, m - размер входного массива nums2.

Объяснение: самый худший вариант - когда все элементы массивов разные, значит нужен такой массив, который будет иметь все элементы этих двух массивов.

## Описание решения:
Используем паттерн "Каждому по указателю" - ставим два указателя на начало двух массивов, создаём цикл с условием, что указатели меньше, чем длины массивов и используем ИЛИ, то есть, что хотя бы один указатель пока что меньше длины своего массива, а внутри цикла как раз делаем проверку выхода за пределы массива для каждого указателя, получается, если один указатель вышел за пределы, то складываем в результирующий массив значение по другому указателю и двигаем этот другой указатель дальше и пропускаем эту итерацию, то есть пишем continue. А затем идут главные условия по движению указателей: проверяем, что если значение по первому указателю меньше значения по второму указателю, то аппендим это меньшее значение и двигаем первый указатель дальше, если значение второго указателя меньше, то аппендим это значение второго указателя и двигаем второй указатель дальше, либо если эти два значения равны, то двигаем оба указателя
