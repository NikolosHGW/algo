## Решение:
```go
func intersect(nums1 []int, nums2 []int) []int {
    l1 := len(nums1)
    l2 := len(nums2)
    
    minLen := minLength(l1, l2)
    
    result := make([]int, 0, minLen)

    p1 := 0
    p2 := 0

    for p1 < l1 && p2 < l2 {
        num1 := nums1[p1]
        num2 := nums2[p2]

        if num1 < num2 {
            p1++
        } else if num2 < num1 {
            p2++
        } else {
            result = append(result, num1)
            p1++
            p2++
        }
    }

    return result
}

func minLength(l1, l2 int) int {
    if l1 < l2 {
        return l1
    }

    return l2
}
```

## Оценка по времени:
O(n + m) - где n - размер входного массива nums1, m - размер входного массива nums2.

Объяснение: с помощью паттерна "каждому по указателю" мы ставим на каждый массив в начало указатель и двигаем до конца массива одним циклом, в итоге получается, что мы должны на двух массивах пройти все элементы в сумме, а массивы могут быть разной длины.

## Оценка по памяти:
O(min(n, m)) - где n - размер входного массива nums1, m - размер входного массива nums2.

Объяснение: самый худший вариант - когда все элементы массивов одинаковы, значит нужен такой массив, который будет иметь все элементы, а это тот массив, который самый короткий, в итоге заполнение массива будет зависить от размера самого минимального из входящих массивов.

## Описание решения:
Используем паттерн "Каждому по указателю" - ставим два указателя на начало двух массивов и двигаем их оба в зависимости от того, кто меньше: мы создаём один цикл, делаем ему такое условие, что мы должны итерироваться пока не пройдём оба массива до конца (p1 < len(nums1)) && (p2 < len(nums2)), на каждой итерации проверяем по какому указателю значение меньше, тот указатель и двигаем вперёд, а если значения равны, то записываем в результирующий массив и двигаем оба указателя
