## Решение:
```go
func urlify(s []rune, k int) []rune {
    p1 := len(s) - 1
    p2 := k - 1

    for p2 >= 0 {
        if s[p2] == ' ' {
            s[p1] = '0'
            p1--
            s[p1] = '2'
            p1--
            s[p1] = '%'
            p1--
        } else {
            s[p1], s[p2] = s[p2], s[p1]
            p1--
        }

        p2--
    }

    return s
}
```

## Оценка по времени:
O(n) - где n - размер входного слайса nums

Объяснение: мы проходим одним указателем по длине k, а вторым указателем по длине n, то есть в сумме будет k + n, но k никогда не может быть больше n, поэтому можно примерно поставить как k = n, n + n = 2n, а 2n - это всё равно n

## Оценка по памяти:
O(1)

Объяснение: здесь аллоцируем только указатели, не создавая новый массив, зависящей от входного массива, так как мы просто переставляем элементы во входном массиве, поэтому память не зависит от размера входящего массива.

## Описание решения:
Решаем проблему техникой "два указателя" паттерном "быстрый и медленный указатели", ставлю быстрый указатель на конец k, то есть там, где нет решёток, а медленный ставлю в самый конец массива. В итоге на каждой итерации всегда двигаю быстрый указатель, а медленный двигаю три раза при условии, что быстрый указатель указывает на пробел, а если не указывает на пробел, то медленный двигаю всего один раз. В итоге, если быстрый указатель указывает на пробел, то я начинаю вставлять %20 по медленному указателю, то бишь, сначала вставляю 0 на то место, где сейчас стоит медленный указатель, потом сдвигаю его вниз, ставлю 2, потом сдвигаю его ещё раз, ставлю % и сдвигаю его ещё раз. А если быстрый указатель не указывает на пробел, то мы делаем свап с медленным. То бишь, медленный всегда указывает на то, куда мы будем что-то вставлять (%, 2, 0 или свап из быстрого)
