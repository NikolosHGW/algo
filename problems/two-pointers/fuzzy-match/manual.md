## Решение:
```go
func fuzzyMatch(s string, t string) bool {
    p1 := 0
    p2 := 0

    for p1 < len(s) && p2 < len(t) {
        if p1 == len(s) - 1 {
            return true
        }

        if s[p1] == t[p2] {
            p1++
            p2++
        } else {
            p2++
        }
    }

    return false
}
```

## Оценка по времени:
O(n + m) - где n - размер s, m - размер t.

Объяснение: с помощью паттерна "каждому по указателю" мы проходим все символы первой сроки и все символы второй строки, то бишь сумма проходов по двум строкам

## Оценка по памяти:
O(1).

Объяснение: здесь у меня аллокации не зависят от размеров входных массивов, две аллокации указателей - всегда постоянные.

## Описание решения:
Создаём два указателя, ставим их на каждую строку, делаем цикл, у которого условие будет проверять, чтоб мы итерировались, пока каждый указатель не обойдёт все индексы в своей строке (p1 < len(s) && p2 < len(t)), затем на каждой итерации нам нужно проверять, если символы не равны, то мы двигаем только второй указатель p2, если равны, то мы двигаем оба указателя, плюс я добавил отдельное условие, что если первый указатель p1 на последнем индексе, это значит, что мы первую строку всю обошли, и нашли все совпадения, значит возвращаю true, а если цикл закончится, ни разу не попав в это условие, то значит совпадений нет, возвращаем false
