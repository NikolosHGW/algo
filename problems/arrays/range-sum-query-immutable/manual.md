## Решение:
```go
type NumArray struct {
    result []int
}


func Constructor(nums []int) NumArray {
    result := make([]int, 0, len(nums) + 1)
    result = append(result, 0)

    for _, num := range nums {
        result = append(result, result[len(result) - 1] + num)
    }
    
    return NumArray{result: result}
}


func (this *NumArray) SumRange(left int, right int) int {
    return this.result[right + 1] - this.result[left]
}


/**
 * Your NumArray object will be instantiated and called as such:
 * obj := Constructor(nums);
 * param_1 := obj.SumRange(left,right);
 */
```

## Оценка по времени:
O(n) - где n - кол-во элементов массиве

Объяснение: прежде, чем найти сумму отрезков, я сначала создаю префиксный массив от оригинального, то есть мне надо пройти по всем элементам оригинального массива, чтобы создать префиксный. А в самой функции уже просто константное время для вычисления операции

## Оценка по памяти:
O(n) - где n - кол-во элементов в массиве

Объяснение: для того, чтобы решить задачу, я создаю префиксный массив, в нём столько же элементов сколько и в основном массиве, то есть я создаю новых n элементов

## Описание решения:
Для решения этой задачи я создаю префиксный массив для оригинального массива, то есть массив, в котором все элементы будут суммой предыдущих элементов в оригинальном массиве. Только для облегчения я ввожу в самое начало префиксного массива число 0, чтобы избежать в коде использования условия для проверки выхода за пределы массива. После того, как создал префиксный массив, я просто беру число из префиксного массива по индексу правого числа интервала (right int) + 1 (+1 нужен, так как у меня введён фейковый 0 в начало перфексного массива, что в свою очередь увеличило размер на + 1) и отнимаю от него число, которое достаю из префиксного массива по индексу левого числа интервала.

## Ревью:
Можно было инициализировать срез make([]int, len(nums)) сразу фиксированной длины, а потом просто с помощью цикла и индекса заполнять его
