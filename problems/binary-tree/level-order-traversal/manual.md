## Решение:
```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func levelOrder(root *TreeNode) [][]int {
    levels := [][]int{}    

    return preorderTraversal(root, 0, levels)
}

func preorderTraversal(node *TreeNode, level int, levels [][]int) [][]int {
    if node == nil {
        return levels
    }

    levelsLen := len(levels)

    if levelsLen <= level {
        levels = append(levels, []int{})
    }

    levels[level] = append(levels[level], node.Val)
    levels = preorderTraversal(node.Left, level + 1, levels)
    levels = preorderTraversal(node.Right, level + 1, levels)

    return levels
}
```

## Оценка по времени:
O(n) - где n кол-во вершин в дереве

Объяснение: чтобы создать новый массив массивов с вершинами в каждом уровне, мне нужно пройтись по каждой вершине дерева.

## Оценка по памяти:
O(n) - где n кол-во значений каждой вершины в дерве

Объяснение: так как я прохожусь по всем вершинам через рекурсивную функцию, то используется стэк, в которую кладутся каждая рекурсивная функция, а их ровно столько же, сколько вершин, так как я вызываю рекурсивную функцию на каждой вершине, то есть O(n). Плюс я создаю новые места в памяти под значение каждой вершины дерева, а значит O(n), в итоге O(n + n) = O(2n) и константу опускаем.

## Описание решения:
Для хранения уровней, в которых хранятся значения вершин, создал слайс слайсов. Затем вызвал рекурсивную функцию, в которую передал корневую ноду, текущий уровень (самый начальный уровень равен 0) и все уровни. В это рекурсивной функции проверяется, что нода не nil, затем идёт проверка, что для текущего уровня существует слайс внутри слайса уровней. Если не существует, то создаём новый слайс с помощью append. Дальше идёт способ preorder, то есть, сначала вставляем значение текущей ноды в текущий уровень, затем вызываем эту же рекурсивную функцию, чтобы обойти левую сторону вершины, то бишь теперь передаём левую вершину текущей вершины (node.Left), текущий уровень + 1 и все уровни. А затем вызываем эту же рекурсивную функцию, чтобы обойти правую сторону вершины, передаём правую вершину текущей вершины, также текущий уровень + 1 и все уровни. И в итоге возвращаем все уровни.
