## Решение:
```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func rightSideView(root *TreeNode) []int {
    result := []int{}

    return preorderTraversal(root, 0, result)
}

func preorderTraversal(node *TreeNode, level int, result []int) []int {
    if node == nil {
        return result
    }

    if len(result) <= level {
        result = append(result, node.Val)
    } else {
        result[level] = node.Val
    }

    result = preorderTraversal(node.Left, level + 1, result)
    result = preorderTraversal(node.Right, level + 1, result)

    return result
}
```

## Оценка по времени:
O(n) - где n - кол-во узлов дерева.

Объяснение: я прохожусь по каждому узлу дерева один раз с помощью рекурсии.

## Оценка по памяти:
O(n) - где n - кол-во узлов дерева.

Объяснение: в решении я использую рекурсию, рекурсивную функцию вызываю на каждом узле, значит в стэк попадает столько фреймов, сколько узлов в дереве O(n) плюс под каждое пройдённое значение узла я создаю в памяти место, чтоб сохранить новый порядок значений узлов в результирующем массиве, а это O(n), в итоге O(2n), где константу опускаем и получается O(n).

## Описание решения:
Для того, чтобы мне получать только крайние правые значения узлов каждого "уровня", я использую обход по дереву через preorder обход с использованием уровня. Создаю результирующий слайс, где храню все значения. Затем вызываю рекурсивную функцию, которая проверяет есть ли текущий уровень в слайсе, если нет, то создаю уровень и кладу в него значение текущей ноды с помощью append, если уровень уже существует, то есть, если в слайсе уже есть на таком индексе значение, то перезаписываю это значение текущей нодой, а затем вызываю рекурсивную функцию для левой ноды, а затем для правой ноды.

## Ревью:
Возможные улучшения: для повышения интуитивности и, возможно, оптимизации можно сначала обходить правое поддерево, а затем левое. Это позволит установить значение уровня при первом посещении узла на этом уровне, избегая перезаписи.
```go
func preorderTraversal(node *TreeNode, level int, result []int) []int {
    if node == nil {
        return result
    }

    if len(result) <= level {
        result = append(result, node.Val)
    }

    // Сначала правое поддерево
    result = preorderTraversal(node.Right, level + 1, result)
    result = preorderTraversal(node.Left, level + 1, result)

    return result
}
```
В этом случае, если правый узел существует, он будет первым добавлен на уровень, и левые узлы не будут перезаписывать его значение.
Если использовать обход правого поддерева первым, можно потенциально уменьшить количество операций записи в срез, что может привести к небольшому улучшению производительности.
